// Generated by gencpp from file set_walk/IKparameter.msg
// DO NOT EDIT!


#ifndef SET_WALK_MESSAGE_IKPARAMETER_H
#define SET_WALK_MESSAGE_IKPARAMETER_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace set_walk
{
template <class ContainerAllocator>
struct IKparameter_
{
  typedef IKparameter_<ContainerAllocator> Type;

  IKparameter_()
    : IKflag(false)
    , ent(0.0)
    , freq(0.0)
    , d_support(0.0)
    , s_support(0.0)
    , test_x(0.0)
    , test_side(0.0)
    , test_yaw(0.0)
    , tuning_x(0.0)
    , tuning_side(0.0)
    , tuning_yaw(0.0)
    , df_x_r(0.0)
    , df_x_l(0.0)
    , df_y_r(0.0)
    , df_y_l(0.0)
    , df_z_r(0.0)
    , df_z_l(0.0)
    , swing_r(0.0)
    , swing_l(0.0)
    , rise_r(0.0)
    , rise_l(0.0)
    , ang10(0)
    , ang11(0)
    , ang12(0)
    , ang13(0)
    , ang14(0)
    , ang15(0)
    , ang16(0)
    , ang17(0)
    , ang18(0)
    , ang19(0)
    , ang20(0)
    , ang21(0)
    , ent_START(0.0)
    , ent_END(0.0)
    , PA_x_f(0.0)
    , PA_x_b(0.0)
    , swing_SIDE_r(0.0)
    , swing_SIDE_l(0.0)
    , mul_SIDEr_r(0.0)
    , mul_SIDEr_l(0.0)
    , mul_SIDEl_r(0.0)
    , mul_SIDDl_l(0.0)
    , swing_START(0.0)
    , swing_END(0.0)
    , rise_START(0.0)
    , rise_END(0.0)
    , PA_YAW_r(0.0)
    , X_YAW_r(0.0)
    , PA_YAW_l(0.0)
    , X_YAW_l(0.0)
    , shoulder_swing(0.0)  {
    }
  IKparameter_(const ContainerAllocator& _alloc)
    : IKflag(false)
    , ent(0.0)
    , freq(0.0)
    , d_support(0.0)
    , s_support(0.0)
    , test_x(0.0)
    , test_side(0.0)
    , test_yaw(0.0)
    , tuning_x(0.0)
    , tuning_side(0.0)
    , tuning_yaw(0.0)
    , df_x_r(0.0)
    , df_x_l(0.0)
    , df_y_r(0.0)
    , df_y_l(0.0)
    , df_z_r(0.0)
    , df_z_l(0.0)
    , swing_r(0.0)
    , swing_l(0.0)
    , rise_r(0.0)
    , rise_l(0.0)
    , ang10(0)
    , ang11(0)
    , ang12(0)
    , ang13(0)
    , ang14(0)
    , ang15(0)
    , ang16(0)
    , ang17(0)
    , ang18(0)
    , ang19(0)
    , ang20(0)
    , ang21(0)
    , ent_START(0.0)
    , ent_END(0.0)
    , PA_x_f(0.0)
    , PA_x_b(0.0)
    , swing_SIDE_r(0.0)
    , swing_SIDE_l(0.0)
    , mul_SIDEr_r(0.0)
    , mul_SIDEr_l(0.0)
    , mul_SIDEl_r(0.0)
    , mul_SIDDl_l(0.0)
    , swing_START(0.0)
    , swing_END(0.0)
    , rise_START(0.0)
    , rise_END(0.0)
    , PA_YAW_r(0.0)
    , X_YAW_r(0.0)
    , PA_YAW_l(0.0)
    , X_YAW_l(0.0)
    , shoulder_swing(0.0)  {
  (void)_alloc;
    }



   typedef uint8_t _IKflag_type;
  _IKflag_type IKflag;

   typedef double _ent_type;
  _ent_type ent;

   typedef double _freq_type;
  _freq_type freq;

   typedef double _d_support_type;
  _d_support_type d_support;

   typedef double _s_support_type;
  _s_support_type s_support;

   typedef double _test_x_type;
  _test_x_type test_x;

   typedef double _test_side_type;
  _test_side_type test_side;

   typedef double _test_yaw_type;
  _test_yaw_type test_yaw;

   typedef double _tuning_x_type;
  _tuning_x_type tuning_x;

   typedef double _tuning_side_type;
  _tuning_side_type tuning_side;

   typedef double _tuning_yaw_type;
  _tuning_yaw_type tuning_yaw;

   typedef double _df_x_r_type;
  _df_x_r_type df_x_r;

   typedef double _df_x_l_type;
  _df_x_l_type df_x_l;

   typedef double _df_y_r_type;
  _df_y_r_type df_y_r;

   typedef double _df_y_l_type;
  _df_y_l_type df_y_l;

   typedef double _df_z_r_type;
  _df_z_r_type df_z_r;

   typedef double _df_z_l_type;
  _df_z_l_type df_z_l;

   typedef double _swing_r_type;
  _swing_r_type swing_r;

   typedef double _swing_l_type;
  _swing_l_type swing_l;

   typedef double _rise_r_type;
  _rise_r_type rise_r;

   typedef double _rise_l_type;
  _rise_l_type rise_l;

   typedef int32_t _ang10_type;
  _ang10_type ang10;

   typedef int32_t _ang11_type;
  _ang11_type ang11;

   typedef int32_t _ang12_type;
  _ang12_type ang12;

   typedef int32_t _ang13_type;
  _ang13_type ang13;

   typedef int32_t _ang14_type;
  _ang14_type ang14;

   typedef int32_t _ang15_type;
  _ang15_type ang15;

   typedef int32_t _ang16_type;
  _ang16_type ang16;

   typedef int32_t _ang17_type;
  _ang17_type ang17;

   typedef int32_t _ang18_type;
  _ang18_type ang18;

   typedef int32_t _ang19_type;
  _ang19_type ang19;

   typedef int32_t _ang20_type;
  _ang20_type ang20;

   typedef int32_t _ang21_type;
  _ang21_type ang21;

   typedef double _ent_START_type;
  _ent_START_type ent_START;

   typedef double _ent_END_type;
  _ent_END_type ent_END;

   typedef double _PA_x_f_type;
  _PA_x_f_type PA_x_f;

   typedef double _PA_x_b_type;
  _PA_x_b_type PA_x_b;

   typedef double _swing_SIDE_r_type;
  _swing_SIDE_r_type swing_SIDE_r;

   typedef double _swing_SIDE_l_type;
  _swing_SIDE_l_type swing_SIDE_l;

   typedef double _mul_SIDEr_r_type;
  _mul_SIDEr_r_type mul_SIDEr_r;

   typedef double _mul_SIDEr_l_type;
  _mul_SIDEr_l_type mul_SIDEr_l;

   typedef double _mul_SIDEl_r_type;
  _mul_SIDEl_r_type mul_SIDEl_r;

   typedef double _mul_SIDDl_l_type;
  _mul_SIDDl_l_type mul_SIDDl_l;

   typedef double _swing_START_type;
  _swing_START_type swing_START;

   typedef double _swing_END_type;
  _swing_END_type swing_END;

   typedef double _rise_START_type;
  _rise_START_type rise_START;

   typedef double _rise_END_type;
  _rise_END_type rise_END;

   typedef double _PA_YAW_r_type;
  _PA_YAW_r_type PA_YAW_r;

   typedef double _X_YAW_r_type;
  _X_YAW_r_type X_YAW_r;

   typedef double _PA_YAW_l_type;
  _PA_YAW_l_type PA_YAW_l;

   typedef double _X_YAW_l_type;
  _X_YAW_l_type X_YAW_l;

   typedef double _shoulder_swing_type;
  _shoulder_swing_type shoulder_swing;





  typedef boost::shared_ptr< ::set_walk::IKparameter_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::set_walk::IKparameter_<ContainerAllocator> const> ConstPtr;

}; // struct IKparameter_

typedef ::set_walk::IKparameter_<std::allocator<void> > IKparameter;

typedef boost::shared_ptr< ::set_walk::IKparameter > IKparameterPtr;
typedef boost::shared_ptr< ::set_walk::IKparameter const> IKparameterConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::set_walk::IKparameter_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::set_walk::IKparameter_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace set_walk

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'set_walk': ['/home/robit/catkin_ws/src/set_walk/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::set_walk::IKparameter_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::set_walk::IKparameter_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::set_walk::IKparameter_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::set_walk::IKparameter_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::set_walk::IKparameter_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::set_walk::IKparameter_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::set_walk::IKparameter_<ContainerAllocator> >
{
  static const char* value()
  {
    return "7c89115aa10660e409ac6fb2d910f757";
  }

  static const char* value(const ::set_walk::IKparameter_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x7c89115aa10660e4ULL;
  static const uint64_t static_value2 = 0x09ac6fb2d910f757ULL;
};

template<class ContainerAllocator>
struct DataType< ::set_walk::IKparameter_<ContainerAllocator> >
{
  static const char* value()
  {
    return "set_walk/IKparameter";
  }

  static const char* value(const ::set_walk::IKparameter_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::set_walk::IKparameter_<ContainerAllocator> >
{
  static const char* value()
  {
    return "bool IKflag\n\
float64 ent\n\
float64 freq\n\
float64 d_support\n\
float64 s_support\n\
float64 test_x\n\
float64 test_side\n\
float64 test_yaw\n\
float64 tuning_x\n\
float64 tuning_side\n\
float64 tuning_yaw\n\
float64 df_x_r\n\
float64 df_x_l\n\
float64 df_y_r\n\
float64 df_y_l\n\
float64 df_z_r\n\
float64 df_z_l\n\
float64 swing_r\n\
float64 swing_l\n\
float64 rise_r\n\
float64 rise_l\n\
int32 ang10\n\
int32 ang11\n\
int32 ang12\n\
int32 ang13\n\
int32 ang14\n\
int32 ang15\n\
int32 ang16\n\
int32 ang17\n\
int32 ang18\n\
int32 ang19\n\
int32 ang20\n\
int32 ang21\n\
float64 ent_START\n\
float64 ent_END\n\
float64 PA_x_f\n\
float64 PA_x_b\n\
float64 swing_SIDE_r\n\
float64 swing_SIDE_l\n\
float64 mul_SIDEr_r\n\
float64 mul_SIDEr_l\n\
float64 mul_SIDEl_r\n\
float64 mul_SIDDl_l\n\
float64 swing_START\n\
float64 swing_END\n\
float64 rise_START\n\
float64 rise_END\n\
float64 PA_YAW_r\n\
float64 X_YAW_r\n\
float64 PA_YAW_l\n\
float64 X_YAW_l\n\
float64 shoulder_swing\n\
\n\
";
  }

  static const char* value(const ::set_walk::IKparameter_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::set_walk::IKparameter_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.IKflag);
      stream.next(m.ent);
      stream.next(m.freq);
      stream.next(m.d_support);
      stream.next(m.s_support);
      stream.next(m.test_x);
      stream.next(m.test_side);
      stream.next(m.test_yaw);
      stream.next(m.tuning_x);
      stream.next(m.tuning_side);
      stream.next(m.tuning_yaw);
      stream.next(m.df_x_r);
      stream.next(m.df_x_l);
      stream.next(m.df_y_r);
      stream.next(m.df_y_l);
      stream.next(m.df_z_r);
      stream.next(m.df_z_l);
      stream.next(m.swing_r);
      stream.next(m.swing_l);
      stream.next(m.rise_r);
      stream.next(m.rise_l);
      stream.next(m.ang10);
      stream.next(m.ang11);
      stream.next(m.ang12);
      stream.next(m.ang13);
      stream.next(m.ang14);
      stream.next(m.ang15);
      stream.next(m.ang16);
      stream.next(m.ang17);
      stream.next(m.ang18);
      stream.next(m.ang19);
      stream.next(m.ang20);
      stream.next(m.ang21);
      stream.next(m.ent_START);
      stream.next(m.ent_END);
      stream.next(m.PA_x_f);
      stream.next(m.PA_x_b);
      stream.next(m.swing_SIDE_r);
      stream.next(m.swing_SIDE_l);
      stream.next(m.mul_SIDEr_r);
      stream.next(m.mul_SIDEr_l);
      stream.next(m.mul_SIDEl_r);
      stream.next(m.mul_SIDDl_l);
      stream.next(m.swing_START);
      stream.next(m.swing_END);
      stream.next(m.rise_START);
      stream.next(m.rise_END);
      stream.next(m.PA_YAW_r);
      stream.next(m.X_YAW_r);
      stream.next(m.PA_YAW_l);
      stream.next(m.X_YAW_l);
      stream.next(m.shoulder_swing);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct IKparameter_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::set_walk::IKparameter_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::set_walk::IKparameter_<ContainerAllocator>& v)
  {
    s << indent << "IKflag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.IKflag);
    s << indent << "ent: ";
    Printer<double>::stream(s, indent + "  ", v.ent);
    s << indent << "freq: ";
    Printer<double>::stream(s, indent + "  ", v.freq);
    s << indent << "d_support: ";
    Printer<double>::stream(s, indent + "  ", v.d_support);
    s << indent << "s_support: ";
    Printer<double>::stream(s, indent + "  ", v.s_support);
    s << indent << "test_x: ";
    Printer<double>::stream(s, indent + "  ", v.test_x);
    s << indent << "test_side: ";
    Printer<double>::stream(s, indent + "  ", v.test_side);
    s << indent << "test_yaw: ";
    Printer<double>::stream(s, indent + "  ", v.test_yaw);
    s << indent << "tuning_x: ";
    Printer<double>::stream(s, indent + "  ", v.tuning_x);
    s << indent << "tuning_side: ";
    Printer<double>::stream(s, indent + "  ", v.tuning_side);
    s << indent << "tuning_yaw: ";
    Printer<double>::stream(s, indent + "  ", v.tuning_yaw);
    s << indent << "df_x_r: ";
    Printer<double>::stream(s, indent + "  ", v.df_x_r);
    s << indent << "df_x_l: ";
    Printer<double>::stream(s, indent + "  ", v.df_x_l);
    s << indent << "df_y_r: ";
    Printer<double>::stream(s, indent + "  ", v.df_y_r);
    s << indent << "df_y_l: ";
    Printer<double>::stream(s, indent + "  ", v.df_y_l);
    s << indent << "df_z_r: ";
    Printer<double>::stream(s, indent + "  ", v.df_z_r);
    s << indent << "df_z_l: ";
    Printer<double>::stream(s, indent + "  ", v.df_z_l);
    s << indent << "swing_r: ";
    Printer<double>::stream(s, indent + "  ", v.swing_r);
    s << indent << "swing_l: ";
    Printer<double>::stream(s, indent + "  ", v.swing_l);
    s << indent << "rise_r: ";
    Printer<double>::stream(s, indent + "  ", v.rise_r);
    s << indent << "rise_l: ";
    Printer<double>::stream(s, indent + "  ", v.rise_l);
    s << indent << "ang10: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ang10);
    s << indent << "ang11: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ang11);
    s << indent << "ang12: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ang12);
    s << indent << "ang13: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ang13);
    s << indent << "ang14: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ang14);
    s << indent << "ang15: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ang15);
    s << indent << "ang16: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ang16);
    s << indent << "ang17: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ang17);
    s << indent << "ang18: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ang18);
    s << indent << "ang19: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ang19);
    s << indent << "ang20: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ang20);
    s << indent << "ang21: ";
    Printer<int32_t>::stream(s, indent + "  ", v.ang21);
    s << indent << "ent_START: ";
    Printer<double>::stream(s, indent + "  ", v.ent_START);
    s << indent << "ent_END: ";
    Printer<double>::stream(s, indent + "  ", v.ent_END);
    s << indent << "PA_x_f: ";
    Printer<double>::stream(s, indent + "  ", v.PA_x_f);
    s << indent << "PA_x_b: ";
    Printer<double>::stream(s, indent + "  ", v.PA_x_b);
    s << indent << "swing_SIDE_r: ";
    Printer<double>::stream(s, indent + "  ", v.swing_SIDE_r);
    s << indent << "swing_SIDE_l: ";
    Printer<double>::stream(s, indent + "  ", v.swing_SIDE_l);
    s << indent << "mul_SIDEr_r: ";
    Printer<double>::stream(s, indent + "  ", v.mul_SIDEr_r);
    s << indent << "mul_SIDEr_l: ";
    Printer<double>::stream(s, indent + "  ", v.mul_SIDEr_l);
    s << indent << "mul_SIDEl_r: ";
    Printer<double>::stream(s, indent + "  ", v.mul_SIDEl_r);
    s << indent << "mul_SIDDl_l: ";
    Printer<double>::stream(s, indent + "  ", v.mul_SIDDl_l);
    s << indent << "swing_START: ";
    Printer<double>::stream(s, indent + "  ", v.swing_START);
    s << indent << "swing_END: ";
    Printer<double>::stream(s, indent + "  ", v.swing_END);
    s << indent << "rise_START: ";
    Printer<double>::stream(s, indent + "  ", v.rise_START);
    s << indent << "rise_END: ";
    Printer<double>::stream(s, indent + "  ", v.rise_END);
    s << indent << "PA_YAW_r: ";
    Printer<double>::stream(s, indent + "  ", v.PA_YAW_r);
    s << indent << "X_YAW_r: ";
    Printer<double>::stream(s, indent + "  ", v.X_YAW_r);
    s << indent << "PA_YAW_l: ";
    Printer<double>::stream(s, indent + "  ", v.PA_YAW_l);
    s << indent << "X_YAW_l: ";
    Printer<double>::stream(s, indent + "  ", v.X_YAW_l);
    s << indent << "shoulder_swing: ";
    Printer<double>::stream(s, indent + "  ", v.shoulder_swing);
  }
};

} // namespace message_operations
} // namespace ros

#endif // SET_WALK_MESSAGE_IKPARAMETER_H
